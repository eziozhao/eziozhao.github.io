<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>可能是最适合新手看的HashMap源码分析</title>
    <link href="/article/d773541b.html"/>
    <url>/article/d773541b.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap使用键值对的存储结构。其底层使用数组实现，应用链地址散列法，并配合红黑树，实现了高效的查找逻辑。本文的HashMap源码基于jdk1.8。</p><span id="more"></span><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>下文经常提到的<strong>桶</strong>就是其实就是table数组中的任意一个位置</p><p>这里变量的含义不理解没关系，看完后面的方法调用就知道了</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//table的初始容量16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><span class="hljs-comment">//最大容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-comment">//默认装载因子0.75 当构造器没提供装载因子时 令loadFactor=0.75f</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><span class="hljs-comment">//table的一个桶中&gt;8个结点时 把桶中的链表转化成红黑树 </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><span class="hljs-comment">//桶中结点&lt;=6个时 把红黑树恢复成链表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><span class="hljs-comment">//table长度超过64时 才进行树化 否则即使单个桶大于等于8个结点也只是调用resize()进行扩容</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br><span class="hljs-comment">//底层数组</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><span class="hljs-comment">//entrySet缓存</span><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br><span class="hljs-comment">//键值对的数量</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br><span class="hljs-comment">//总调整次数</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><span class="hljs-comment">//扩容的门槛 超过这个值需要扩容 其值capacity * load_factor</span><br><span class="hljs-keyword">int</span> threshold;<br><span class="hljs-comment">//装载因子</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法总共有4个 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//1、默认构造方法 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>   &#125;<br><span class="hljs-comment">//2、自定义初始容量的构造方法 使用默认装载因子 调用了构造方法3</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>   &#125;<br><span class="hljs-comment">//3、自定义初始容量和装载因子</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                              initialCapacity);<br>       <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>           initialCapacity = MAXIMUM_CAPACITY;<br>       <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                              loadFactor);<br>       <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>       <span class="hljs-comment">//扩容门槛设置 这个值后期被当作了table容量 </span><br>       <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>   &#125;<br><span class="hljs-comment">//4、以一个map的键值对为基础构建hashmap</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>       putMapEntries(m, <span class="hljs-keyword">false</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="tableSizeFor-int-cap-方法"><a href="#tableSizeFor-int-cap-方法" class="headerlink" title="tableSizeFor(int cap) 方法"></a>tableSizeFor(int cap) 方法</h3><p>在构造方法3中，threshold是通过<code>tableSizeFor</code>计算的，看一下这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法的作用是找到一个最小k使得<code>2^k&gt;=cap</code>，这一操作使得不论构造函数中传入的initialCapacity是多少，最终都会被<code>tableSizeFor</code>处理成<code>2^k</code>形式 ,这一操作后续会解释作用。</p><p>简单解释一下为什么tableSizeFor可以实现这种效果。假设cap=6，则n=6-1=5。n的二进制即为<code>101</code>，无符号右移之后变为<code>010</code>，则<code>101 | 010 = 111</code>。新的n为<code>111</code>，那么后续再移位之后，因为进行的是<code>或</code>操作，所以每次得到的结果都是<code>111</code>。最终return了n+1，即<code>1000</code>对应十进制的8，也就是<code>2^3</code>。</p><p>可以看出，每次的移位取或操作都让n的二进制高位开始的连续1的数量翻倍，因为在构造函数3中限制了initialCapacity的最大值为<code>MAXIMUM_CAPACITY=1 &lt;&lt; 30</code>，所以最极端的情况下，n最终的二进制会对应30个1，最后再加1，正好是<code>2^30</code>。</p><p>那么第一步取n的时候，为什么要令n=cap-1呢？假如一开始cap就是<code>2^k</code>，那么如果一开始不进行减1的操作，最终的n会等于<code>2^(k+1)</code>，这显然不是我们想要的结果。所以先让cap减1，这时n对应的二进制就是k个1,移位取或操作对其没有影响。最后return时，n+1又变回了<code>2^k</code>。</p><h3 id="put-K-key-V-value-方法"><a href="#put-K-key-V-value-方法" class="headerlink" title="put(K key, V value)方法"></a>put(K key, V value)方法</h3><p>存入键值对的方法，实际是通过putVal方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="hash-Object-key-方法"><a href="#hash-Object-key-方法" class="headerlink" title="hash(Object key)方法"></a>hash(Object key)方法</h4><p>计算key的hash值，因为key.hashCode是一个int值，<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>相当于把高16位和低16位进行异或，使分布更松散。具体原因可以参看知乎的这个<a href="https://www.zhihu.com/question/20733617">高赞答案</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h4><p>介绍putVal前，我们先看一张图，直观的感受一下hashmap是如何存储数据的。可以看出当table中的一个桶的结点数目超过临界值时，会把原先的链表转化成红黑树。这里的转化还有个前提条件是table的长度要大于等于64，图中为了方便没有体现这点。</p><p><img src="https://gitee.com/eziozhao/image/raw/master/Img/20210220220850.png" alt="image-20210220220849961"></p><h5 id="方法流程"><a href="#方法流程" class="headerlink" title="方法流程"></a>方法流程</h5><ol><li>如果一开始table为空则调用扩容方法初始化table</li><li>如果待插入的桶为空则直接插入</li><li>如果这个桶已经有元素，并且第一个元素的hash值和待插入元素相同，转到后续处理，否则转到4</li><li>处理hash冲突，如果是树节点，则按照红黑树逻辑处理；如果是普通结点，则遍历链表寻找是否存在与待插入元素相同的key。如果找到了key，跳出遍历，转到5，否则转到6</li><li>根据onlyIfAbsent判断是否需要更新旧的value，return oldValue之后方法结束</li><li>在链表末尾插入新结点，并判断结点数量是否到达临界值，达到临界值则树化。转到7</li><li>结点总数加1，并判断是否需要扩容</li></ol><p>下面看具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">//如果table还没进行初始化 调用resize进行初始化</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">//如果当前hash值对应的位置是空的 直接把这个键值对放进去</span><br>    <span class="hljs-comment">//(n - 1) &amp; hash 相当于 hash % n, 具体原因后文介绍</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">//如果这个位置已经有元素了 使用链地址法散列</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//如果table当前位置的第一个结点p的key与待插入的key相同</span><br>        <span class="hljs-comment">//保存p的值 后续直接更新value即可</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">//如果p是树节点，则按照树的逻辑插入</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//否则遍历当前位置对应的链表 找到插入位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">//如果到了链表末尾还没找到key值相同的结点，则把新节点放在链表末尾</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//存入末尾</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">//如果链表长度超过临界值 将链表树化</span><br>                    <span class="hljs-comment">//bincount少算了第一个结点,所以需要减1</span><br>                    <span class="hljs-comment">//需要注意 这时bincount并没有算newNode </span><br>                    <span class="hljs-comment">//所以树化时 实际上已经有9个结点</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//在链表中找到了与待插入key相同的元素 结束循环 后续直接修改value</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//e不等于null说明链表中有和待插入key一样的键值 所以直接用新的value更新旧值</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">//onlyIfAbsent默认false表示当待插入key已经存在时 用新的value更新oldValue</span><br>            <span class="hljs-comment">//否则保持原先的key-value不变</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            <span class="hljs-comment">//hashmap中这个方法为空 LinkedHashMap才会用到</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">//返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//map中不存在与待插入元素相同的key时 把修改次数加1</span><br>    ++modCount;<br>    <span class="hljs-comment">//结点数加1 如果超过了threshold就扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">//这个方法也是LinkedHashMap才会用到</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在解释一下上文注释中提到的问题</p><p><strong>(n - 1) &amp; hash的作用</strong></p><p>首先hash是一个int范围的数，在java中即为-2147483648 至2147483647。如果直接把所有的hash都对应到table数组的索引，那<code>table.length</code>要超过40亿！这显然不科学。因此，我们可以把<code>hash % n</code>当作索引值，这样范围就小很多了。</p><p>而对于计算机来说，&amp;运算要比%快。并且，<strong>只有table的长度是2的k次幂时</strong>，<code>(n - 1) &amp; hash</code>才等于<code>hash % n</code>。这又是为什么？首先，当<code>n = 2^k</code>时，n-1对应的2进制是k个1，所以<code>(n - 1) &amp; hash</code>取到的是hash中的最后k位的值，因为hash的二进制中，倒数第k位之前的部分代表的值一定是n的倍数，所以必然为0，因此最后k位代表的值正是<code>hash % n</code>的结果。<strong>这也解释了为什么table的长度一定要是2的k次幂。</strong></p><p>下面给出示意图，以n=8，hash=75为例</p><p><img src="https://gitee.com/eziozhao/image/raw/master/Img/20210220172321.png" alt="image-20210220172321726"></p><h4 id="resize-扩容方法"><a href="#resize-扩容方法" class="headerlink" title="resize() 扩容方法"></a>resize() 扩容方法</h4><p>用于初始化table或者将table容量翻倍</p><h5 id="方法流程-1"><a href="#方法流程-1" class="headerlink" title="方法流程"></a>方法流程</h5><ol><li>旧容量大于0，判断容量翻倍后是否超过上限，如果不超过则翻倍。如果旧门槛翻倍后溢出，转到4</li><li>旧容量等于0，旧门槛大于0时，让新容量等于旧门槛。转到4</li><li>旧容量和旧门槛都是0，则用默认值进行初始化</li><li>用newCap * loadFactor计算出新门槛</li><li>按照新容量建立新数组</li><li>将旧数组的元素映射到新数组，并且将原来桶中的链表拆成两部分，低位的还在原来桶的位置j，高位的放到oldCap+j的位置，oldCap是旧容量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-comment">//旧容量</span><br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-comment">//旧门槛</span><br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//旧容量大于0 说明已经初始化过 </span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//旧容量超过了最大容量 直接设置门槛值为最大int 以后就不会扩容了</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">//旧容量的2倍仍在最大容量之内且旧容量大于等于16 则将容量和门槛值都翻倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <br>        <span class="hljs-comment">//如果调用了含参的构造方法 第一次putVal时会进入这里 这时oldCap=0</span><br>        <span class="hljs-comment">//此时让新容量等于旧门槛值 新门槛值在后面算</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <br>        <span class="hljs-comment">//如果调用HashMap()构造方法会进入这个分支 oldCap和oldThr都是0 </span><br>        <span class="hljs-comment">//用默认值进行初始化</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">//newThr等于0可能是两种情况导致的</span><br>    <span class="hljs-comment">//其一 代码进入oldCap &gt; 0 分支后 由于newThr = oldThr &lt;&lt; 1;导致newThr溢出 变成0</span><br>    <span class="hljs-comment">//其二 代码进入oldThr &gt; 0 分支 没有计算newThr</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//按公式计算newThr</span><br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    <span class="hljs-comment">//更新门槛值</span><br>    threshold = newThr;<br>    <span class="hljs-comment">//按照扩容后的容量新建数组</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//遍历旧数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">//如果当前桶中只有一个元素 直接将他映射到新数组对应位置</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">//如果是树节点 则对树进行拆分之后再映射</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-comment">//桶中不止一个元素 且不是树 则将桶中对应的链表元素按条件拆成两个链表</span><br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">//假设oldCap = 2^k</span><br>                        <span class="hljs-comment">//则二进制hash值从低到高的第k+1位为0的进入这个分支</span><br>                        <span class="hljs-comment">//分支中就是链表连接操作</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">//二进制hash值从低到高的第k+1位为1的进入这个分支</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">//low链表在新数组中的位置其实和原数组一样</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">//high链表在新数组中的位置比原数组大oldCap</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="get-Object-key-方法"><a href="#get-Object-key-方法" class="headerlink" title="get(Object key)方法"></a>get(Object key)方法</h3><p>根据key获取value</p><h5 id="方法流程-2"><a href="#方法流程-2" class="headerlink" title="方法流程"></a>方法流程</h5><ol><li>根据key的hash值查找table对应的位置，如果不为空则转到2，否则直接返回null</li><li>判断桶中第一个元素是不是想要的，如果是，直接返回，否则到3</li><li>如果桶中结点不止一个，则树节点使用二叉平衡树的逻辑查找，普通结点遍历链表查找</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;<br>    <span class="hljs-comment">//table不为空 且hash对应的位置不为空 进入分支</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//先查看桶中第一个结点是不是想要的 如果是 直接返回</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">//第一个结点不是要找的 并且桶中不止一个结点 那么遍历桶中元素</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//如果是树节点 调用树的查找方法 使用的是二叉平衡树查找的方法</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">//否则 遍历链表</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getTreeNode-int-h-Object-k"><a href="#getTreeNode-int-h-Object-k" class="headerlink" title="getTreeNode(int h, Object k)"></a>getTreeNode(int h, Object k)</h4><p>getTreeNode是TreeNode类的方法，这里放上简化后的TreeNode类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>        TreeNode&lt;K,V&gt; left;<br>        TreeNode&lt;K,V&gt; right;<br>        TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        <span class="hljs-keyword">boolean</span> red;<br>        <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">getTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k)</span> </span>&#123;<br>            <span class="hljs-comment">//调用getTreeNode方法的结点parent不空 则从这棵树的根节点开始查找</span><br>            <span class="hljs-keyword">return</span> ((parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>).find(h, k, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    <span class="hljs-comment">//平衡二叉树查找</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;<br>            TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">int</span> ph, dir; K pk;<br>                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;<br>                <span class="hljs-comment">//根节点hash比h大 去左子树查找</span><br>                <span class="hljs-keyword">if</span> ((ph = p.hash) &gt; h)<br>                    p = pl;<br>                <span class="hljs-comment">//否则去右子树查找</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ph &lt; h)<br>                    p = pr;<br>                <span class="hljs-comment">//key相同 找到了</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((pk = p.key) == k || (k != <span class="hljs-keyword">null</span> &amp;&amp; k.equals(pk)))<br>                    <span class="hljs-keyword">return</span> p;<br>                <span class="hljs-comment">//左子树为空 查找右子树</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pl == <span class="hljs-keyword">null</span>)<br>                    p = pr;<br>                <span class="hljs-comment">//右子树为空 查左子树</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pr == <span class="hljs-keyword">null</span>)<br>                    p = pl;<br>                <span class="hljs-comment">//根据用户传入的比较逻辑 进行比较</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((kc != <span class="hljs-keyword">null</span> ||<br>                          (kc = comparableClassFor(k)) != <span class="hljs-keyword">null</span>) &amp;&amp;<br>                         (dir = compareComparables(kc, k, pk)) != <span class="hljs-number">0</span>)<br>                    p = (dir &lt; <span class="hljs-number">0</span>) ? pl : pr;<br>                <span class="hljs-comment">//上述条件都不满足 直接去右子树查找</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-keyword">return</span> q;<br>                <span class="hljs-comment">//去左子树查找</span><br>                <span class="hljs-keyword">else</span><br>                    p = pl;<br>            &#125; <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="remove-Object-key-方法"><a href="#remove-Object-key-方法" class="headerlink" title="remove(Object key)方法"></a>remove(Object key)方法</h3><p>根据key删除元素</p><h5 id="方法流程-3"><a href="#方法流程-3" class="headerlink" title="方法流程"></a>方法流程</h5><ol><li>根据key的hash值查找对应的桶</li><li>如果是空桶直接返回null</li><li>如果桶不为空，且第一个元素就是要删除的，用node保留这个结点。否则转到4</li><li>查看后续元素，如果是树结点，则调用树的逻辑，普通结点则遍历链表</li><li>如果找到了要删除的结点，则进行删除，否则返回null</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ?<br>        <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;<br>        <span class="hljs-comment">//桶中第一个元素就是要删除的元素 则用node保留p</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-comment">//第一个元素不是要删除的 则查看后续元素</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//如果是树 则用红黑树的逻辑删除</span><br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//否则 遍历链表</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                         (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//找到了要删除的点 </span><br>        <span class="hljs-comment">//如果matchValue为false 则直接开始删除</span><br>        <span class="hljs-comment">//如果matchValue为true 则还要检查value是否匹配</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                             (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-comment">//树节点删除</span><br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);<br>            <span class="hljs-comment">//如果要删除的是桶的第一个元素 直接让桶头指向第二个元素</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                tab[index] = node.next;<br>            <span class="hljs-comment">//普通链表 删除结点</span><br>            <span class="hljs-keyword">else</span><br>                p.next = node.next;<br>            ++modCount;<br>            <span class="hljs-comment">//元素个数减1</span><br>            --size;<br>            <span class="hljs-comment">//此处函数体为空 LinkedHashMap才会使用afterNodeRemoval</span><br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了从HashMap最常用的put、get、remove方法入手，分析了其关联方法的代码。</p><p>其中，红黑树的插入删除逻辑等文中没有具体分析。计划之后专门写一篇红黑树的文章，再将这部分补充上。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6844903817855631373#heading-17">https://juejin.cn/post/6844903817855631373#heading-17</a></p><p><a href="https://segmentfault.com/a/1190000012926722">https://segmentfault.com/a/1190000012926722</a></p>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA源码详解之优先队列PriorityQueue（逐行注释）</title>
    <link href="/article/f6a391.html"/>
    <url>/article/f6a391.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>优先队列是JAVA以堆排序为基础实现的数据结构，这种结构在删除或新增元素后，会自动进行重排，非常方便。本文分析优先队列中的常用方法源码来加强理解。</p><span id="more"></span><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>所谓<strong>堆</strong>，是一种完全二叉树。如果这颗树的父节点值大于等于子节点值，则称为大顶堆。如果父节点值小于等于子节点，则成为小顶堆。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>1、将序列中的n个元素构造成<strong>堆</strong></p><p>2、<strong>堆顶</strong>与序列末尾元素交换，这样末尾元素就成了整个序列的最大（最小）值</p><p>3、对当前序列的前n-1个元素重复1和2</p><p>有关堆排序的详解可以参考这篇<a href="https://www.cnblogs.com/chengxiao/p/6129630.html#!comments">文章</a>。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认容量11</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">11</span>;<br><span class="hljs-comment">//队列中元素的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//定义比较规则 不传该参数时 默认使用小顶堆</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator;<br><span class="hljs-comment">//底层使用数组保存队列元素</span><br><span class="hljs-keyword">transient</span> Object[] queue;<br><span class="hljs-comment">//堆的重新结构化次数</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount = <span class="hljs-number">0</span>; <br></code></pre></td></tr></table></figure><p>对offer()、poll()、remove()这3个方法及它们的关联方法进行分析，其他方法都很简单，直接看源码即可。</p><h3 id="offer-E-e-方法"><a href="#offer-E-e-方法" class="headerlink" title="offer(E e) 方法"></a><code>offer(E e)</code> 方法</h3><h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><p>每次调用offer()方法时，队列已经是堆的状态的了，offer的元素先假定放在队尾，然后自下向上重构堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">//不能增加null元素</span><br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    modCount++;<br>    <span class="hljs-comment">//当前要增加元素的位置 因为数组索引从0开始 所以取size即可</span><br>    <span class="hljs-keyword">int</span> i = size;<br>    <span class="hljs-comment">//如果容量不够了 进行扩容</span><br>    <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>        grow(i + <span class="hljs-number">1</span>);<br>    size = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//如果是第一个添加的元素 不需要进行排序 直接赋值即可</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>        queue[<span class="hljs-number">0</span>] = e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//否则 自下向上重构堆</span><br>        siftUp(i, e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="siftUp-int-k-E-x-自下向上-重构堆"><a href="#siftUp-int-k-E-x-自下向上-重构堆" class="headerlink" title="siftUp(int k, E x) 自下向上 重构堆"></a><code>siftUp(int k, E x)</code> 自下向上 重构堆</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (comparator != <span class="hljs-keyword">null</span>)<br>           <span class="hljs-comment">//传入了比较器</span><br>           siftUpUsingComparator(k, x);<br>       <span class="hljs-keyword">else</span><br>           <span class="hljs-comment">//默认的比较方法</span><br>           siftUpComparable(k, x);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftUpComparable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;<br>       Comparable&lt;? <span class="hljs-keyword">super</span> E&gt; key = (Comparable&lt;? <span class="hljs-keyword">super</span> E&gt;) x;<br>       <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">//求出父节点</span><br>           <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>           <span class="hljs-comment">//取父节点元素</span><br>           Object e = queue[parent];<br>           <span class="hljs-comment">//如果要插入的元素比父节点大 结束循环</span><br>           <span class="hljs-keyword">if</span> (key.compareTo((E) e) &gt;= <span class="hljs-number">0</span>)<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-comment">//否则 将要插入的元素与父节点交换位置</span><br>           queue[k] = e;<br>           <span class="hljs-comment">//将k指向父节点 继续向上比较</span><br>           k = parent;<br>       &#125;<br>       <span class="hljs-comment">//循环结束 说明k到达了根节点 或者要插入的元素比父节点大了 找到了最终要插入的位置</span><br>       queue[k] = key;<br>   &#125;<br><span class="hljs-comment">//使用自定义比较器 逻辑与上面的默认方法相同</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftUpUsingComparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;<br>       <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>           Object e = queue[parent];<br>           <span class="hljs-keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="hljs-number">0</span>)<br>               <span class="hljs-keyword">break</span>;<br>           queue[k] = e;<br>           k = parent;<br>       &#125;<br>       queue[k] = x;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="grow-int-minCapacity-扩容的方法"><a href="#grow-int-minCapacity-扩容的方法" class="headerlink" title="grow(int minCapacity) 扩容的方法"></a><code>grow(int minCapacity)</code> 扩容的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> oldCapacity = queue.length;<br>    <span class="hljs-comment">// 旧容量小于64时 直接翻倍 否则容量增加50%</span><br>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="hljs-number">64</span>) ?<br>                                     (oldCapacity + <span class="hljs-number">2</span>) :<br>                                     (oldCapacity &gt;&gt; <span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// 超出最大容量时 重设容量</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">//拷贝原数组 并将其数组长度扩充至newCapacity</span><br>    queue = Arrays.copyOf(queue, newCapacity);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>        MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="poll-方法"><a href="#poll-方法" class="headerlink" title="poll()方法"></a><code>poll()</code>方法</h3><p>每次取出队首元素后，假定队尾元素放置队首，然后自上向下重构堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//最后一个元素的索引</span><br>    <span class="hljs-keyword">int</span> s = --size;<br>    modCount++;<br>    <span class="hljs-comment">//取出堆顶元素</span><br>    E result = (E) queue[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//队尾元素</span><br>    E x = (E) queue[s];<br>    <span class="hljs-comment">//删除队尾元素</span><br>    queue[s] = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//如果队列中元素个数大于1 则必定大于0 需要重构堆</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">//队尾元素移到队首 进行重构</span><br>        siftDown(<span class="hljs-number">0</span>, x);<br>    <span class="hljs-comment">//否则说明队列中只有一个元素 直接返回即可</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="siftDown-int-k-E-x-自上向下-重构堆"><a href="#siftDown-int-k-E-x-自上向下-重构堆" class="headerlink" title="siftDown(int k, E x) 自上向下 重构堆"></a><code>siftDown(int k, E x)</code> 自上向下 重构堆</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (comparator != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">//带比较器</span><br>        siftDownUsingComparator(k, x);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//默认方法</span><br>        siftDownComparable(k, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftDownComparable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;<br>    Comparable&lt;? <span class="hljs-keyword">super</span> E&gt; key = (Comparable&lt;? <span class="hljs-keyword">super</span> E&gt;)x;<br>    <span class="hljs-comment">//half为非叶子结点的个数</span><br>    <span class="hljs-comment">//因为堆结构是完全二叉树 设树中度为0的节点个数是n0,度为1的是n1,度为2的个数是n2</span><br>    <span class="hljs-comment">//则n0 + n1 + n2 = n, 又因为二叉树中 n2 + 1 = n0 </span><br>    <span class="hljs-comment">//联立上面的两个等式 得出n0 = (n - n1 + 1) / 2</span><br>    <span class="hljs-comment">//因为完全二叉树中n1等于0或1 所以n0是n/2向上取整</span><br>    <span class="hljs-comment">//所以非叶子结点个数即为n/2向下取整</span><br>    <span class="hljs-keyword">int</span> half = size &gt;&gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-comment">// loop while a non-leaf</span><br>    <span class="hljs-comment">//只需比较将队尾元素与非叶子结点比较即可</span><br>    <span class="hljs-comment">//这样比较结束之后已经可以保证堆重构完成</span><br>    <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>        <span class="hljs-comment">//左孩子结点</span><br>        <span class="hljs-keyword">int</span> child = (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// assume left child is least</span><br>        Object c = queue[child];<br>        <span class="hljs-keyword">int</span> right = child + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//取左右孩子中较小的赋值给c</span><br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp;<br>            ((Comparable&lt;? <span class="hljs-keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="hljs-number">0</span>)<br>            c = queue[child = right];<br>        <span class="hljs-comment">//如果key比左右孩子都小 循环结束</span><br>        <span class="hljs-keyword">if</span> (key.compareTo((E) c) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//否则 将较小的孩子结点上移</span><br>        queue[k] = c;<br>        <span class="hljs-comment">//让k指向孩子结点 继续比较下一层</span><br>        k = child;<br>    &#125;<br>    <span class="hljs-comment">//找到了要插入的位置</span><br>    queue[k] = key;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftDownUsingComparator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, E x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> half = size &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>        <span class="hljs-keyword">int</span> child = (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        Object c = queue[child];<br>        <span class="hljs-keyword">int</span> right = child + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp;<br>            comparator.compare((E) c, (E) queue[right]) &gt; <span class="hljs-number">0</span>)<br>            c = queue[child = right];<br>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = c;<br>        k = child;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中可以看出，调用<code>poll()</code>之后，重构堆时，只是保证了堆顶元素最小，但是左右孩子结点的大小关系不一定，所以底层数组不一定是完全有序的。这本来也是堆结构的性质。我们用一段代码来验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; queue=<span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>queue.add(<span class="hljs-number">1</span>);<br>queue.add(<span class="hljs-number">2</span>);<br>queue.add(<span class="hljs-number">3</span>);<br>queue.add(<span class="hljs-number">4</span>);<br>queue.add(<span class="hljs-number">5</span>);<br>System.out.println(Arrays.toString(queue.toArray())); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br>queue.poll();<span class="hljs-comment">//poll之后 队首最小 但是整个队列不是有序的</span><br>System.out.println(Arrays.toString(queue.toArray())); <span class="hljs-comment">// [2, 4, 3, 5]</span><br></code></pre></td></tr></table></figure><h3 id="remove-Object-o-方法"><a href="#remove-Object-o-方法" class="headerlink" title="remove(Object o) 方法"></a><code>remove(Object o) </code>方法</h3><p>删除指定元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-comment">//元素索引</span><br>    <span class="hljs-keyword">int</span> i = indexOf(o);<br>    <span class="hljs-keyword">if</span> (i == -<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//删除元素</span><br>        removeAt(i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (o.equals(queue[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="removeAt-int-i-删除指定位置元素"><a href="#removeAt-int-i-删除指定位置元素" class="headerlink" title="removeAt(int i) 删除指定位置元素"></a><code>removeAt(int i)</code> 删除指定位置元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">removeAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span><br>    modCount++;<br>    <span class="hljs-keyword">int</span> s = --size;<br>    <span class="hljs-keyword">if</span> (s == i) <span class="hljs-comment">// removed last element</span><br>        queue[i] = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//队尾元素</span><br>        E moved = (E) queue[s];<br>        <span class="hljs-comment">//队尾删除</span><br>        queue[s] = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//以i为根结点 自上向下重构堆</span><br>        siftDown(i, moved);<br>        <span class="hljs-comment">//queue[i]==move说明moved直接放在了i的位置</span><br>        <span class="hljs-keyword">if</span> (queue[i] == moved) &#123;<br>            <span class="hljs-comment">//尝试能否向堆的上层移动</span><br>            siftUp(i, moved);<br>            <span class="hljs-comment">//如果能向上移动 返回moved</span><br>            <span class="hljs-keyword">if</span> (queue[i] != moved)<br>                <span class="hljs-keyword">return</span> moved;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果删除元素后 队尾元素直接放在i的位置就能满足堆结构 那就返回null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP的三次握手和四次挥手详解</title>
    <link href="/article/a44e94be.html"/>
    <url>/article/a44e94be.html</url>
    
    <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h4 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h4><p>面向连接的可靠字节流服务。</p><span id="more"></span><h4 id="建立连接——三次握手"><a href="#建立连接——三次握手" class="headerlink" title="建立连接——三次握手"></a>建立连接——三次握手</h4><p>TCP建立连接时，需要经历下图所示的三次握手过程。</p><p><img src="https://gitee.com/eziozhao/image/raw/master/Img/20210210212551.jpg" alt="三次握手"></p><p>每一次握手都可以反映出不同的信息。</p><p><strong>第一次握手</strong></p><p>SYN标志提示TCP连接的服务端检查序列编号(seq)，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。客户端通过<strong>SYN=1</strong>来告诉服务端它想要建立连接。<strong>SYN=1的报文段不携带数据，但是也要消耗一个序号。</strong></p><p>seq是基于时钟生成一个序号，每4微秒加1，到2^32-1时又从0开始。tcp提供全双工服务，客户端和服务端都有各自的序号。<strong>编号是为了解决网络包乱序的问题</strong>。</p><p>第一次握手成功后，<strong>服务器可以知道客户端的发送能力是正常的，服务器自己的接收能力是正常的</strong>。</p><p><strong>第二次握手</strong></p><p>服务端用<strong>SYN=1和ACK=1</strong>来表示这条数据报是针对之前的连接请求的应答。</p><p><strong>ack=m+1</strong>表示服务端已经收到了到<strong>m</strong>为止的报文，期待的下一个报文是<strong>m+1</strong>。</p><p>第二次握手成功后，<strong>客户端知道了服务端的接收和发送能力正常，客户端自己的接收和发送能力是正常的</strong>。</p><p><strong>第三次握手</strong></p><p>客户端发送确认包(ACK=1)进行应答，<strong>ack=n+1</strong>表示n为止的序号都收到了，下一次希望收到序号是n+1的报文。</p><p>seq=m+1表示当前序号时m+1，需要注意的是，<strong>ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</strong>。<strong>所以下一个报文的序号还是m+1。</strong></p><p>服务端检查ack的值以及ACK=1，接收成功，第三次握手完成。</p><p>这时，因为收到了正确的回传，说明第二次握手的信息客户端正确接收了，所以<strong>服务端知道了客户端的接收能力是正常的，同时也说明了服务器自己的发送能力是正常的。</strong></p><p>至此，客户端和服务端都确定了自己和对方的发送、接收都是正常了，tcp连接建立完成。</p><p><strong>问题：建立连接为什么一定要3次握手？两次可以吗</strong></p><p>不可以。</p><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><p>阻止历史连接</p><p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li><li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li></ul><p>如果是两次握手，服务端在收到第一次握手时，就进入了连接状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务段在第一次握手的时候就进入 ESTABLISHED 状态，在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，浪费资源。</p><h4 id="断开连接——四次挥手"><a href="#断开连接——四次挥手" class="headerlink" title="断开连接——四次挥手"></a>断开连接——四次挥手</h4><p>TCP 是<strong>全双工</strong> 的， 每个方向必须单独地进行关闭。断开连接时需要进行4次握手。</p><p><img src="https://gitee.com/eziozhao/image/raw/master/Img/20210211194514.jpg" alt="tcp四次挥手"></p><p><strong>第一次挥手</strong></p><p><strong>FIN=1</strong>表示要关闭连接，<strong>seq=x</strong>是当前报文序号。这次挥手表示客户端已经没有数据要发送了，想要断开连接。客户机进入<strong>终止等待1</strong>。</p><p><strong>第二次挥手</strong></p><p>服务端收到第一次挥手的报文后，通知上层应用程序对方已经请求断开连接，并且回复给客户端一个ACK确认报文。服务器进入<strong>关闭等待</strong>状态，此时，服务器还可以继续发送那些尚未发送完成的数据，客户端也可以接收。客户端收到确认报文后进入<strong>终止等待2</strong>。</p><p><strong>第三次挥手</strong></p><p>服务器发送完所有的数据后，发送一个<strong>FIN=1</strong>的报文表示自己可以断开连接了。因为第二次挥手后，服务器有可能又发送了一些数据，所以此时的seq是一个新的序列号z。服务器进入最终确认阶段。</p><p><strong>第四次挥手</strong></p><p>客户端收到服务器的FIN报文后，恢复一个ACK确认报文，服务器接到这个确认报文后直接关闭连接。而客户端在发出FIN报文后先是进入<strong>时间等待</strong>状态，经过**2MSL **(两倍的报文段最大存活时间，常用值有30秒、1分钟和2分钟) 的时间后，客户端也进入关闭状态。</p><p>至此，tcp连接关闭。</p><p><strong>问题：为什么建立连接时3次握手就可以，而关闭时需要4次？</strong></p><p>建立连接时，服务端收到第一次握手SYN请求后可以直接回复一个SYN+ACK报文，一方面确认了自己收到了客户端的连接请求，另一方面也表明自己也同意连接。</p><p>然而，关闭连接时，服务端收到客户端的FIN报文时，可能还有数据没有发送完，服务端不能立刻停止连接，它只能先发送一个确认报文给客户端。等到服务端的数据都发完了，才能向客户端发送FIN报文。所以需要4次握手。</p><p><strong>问题：为什么要有2MSL的时间等待？</strong></p><p>因为网络可能不稳定，导致第4次握手的ACK报文迟迟没有被服务器收到，服务器会一直超时重传FIN报文，如何客户端已经关闭，就无法处理了。所以客户端在送出第4次挥手的报文后，会等待一段时间，这段时间内没收到FIN报文，说明服务器已经收到了确认报文，客户端就可以关闭了。至于为什么时间设置成2MSL，可以这样理解：</p><p>1、如果客户机发送的第3次挥手报文不能顺利到达服务器，那么服务器那边等待的时间不可能比MSL更长，所以在一个MSL的时间内，服务器一定会重传一个FIN报文。</p><p>2、这个FIN报文最多存活MSL的时间，也就是说客户端一定会在一个MSL的时间内收到这个报文。</p><p>上面两个步骤加在一起，客户端最多等2MSL的时间，就可以确定能否关闭连接了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000022410446">https://segmentfault.com/a/1190000022410446</a></p><p><a href="https://zhuanlan.zhihu.com/p/40013850">https://zhuanlan.zhihu.com/p/40013850</a></p><p><a href="https://juejin.cn/post/6844903685563105293">https://juejin.cn/post/6844903685563105293</a></p><p><a href="https://www.zhihu.com/question/271701044/answer/1279809269">https://www.zhihu.com/question/271701044/answer/1279809269</a></p>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天天都用浏览器的你知道输入网址后发生了什么吗？</title>
    <link href="/article/56265d99.html"/>
    <url>/article/56265d99.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>浏览器是如今必不可少的工具之一，每天都有无数人通过浏览器获取自己需要的信息。那么当你在浏览器中键入一行网址后究竟发生了什么？我们下面一起捋一捋。</p><span id="more"></span><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://gitee.com/eziozhao/image/raw/master/Img/20210210161438.jpg" alt="输入url到加载页面"></p><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h4 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h4><p>所谓解析就是把方便人类记忆的域名翻译成计算机的ip地址。比如输入的url是<code>www.baidu.com</code>，首先在<strong>本地域名服务器</strong>中寻找ip地址，如果没找到，本地域名服务器会请求<strong>根域名服务器</strong>寻找，如果还是没找到，本地域名服务器会请求<strong>com顶级域名服务器</strong>，如果还找不到，那么本地域名服务器继续请求<strong>baidu.com域服务器</strong>。</p><p>在linux命令行中输入<code>dig baidu.com +trace</code>可以详细看到dns解析过程。</p><p>1、查询了根域名服务器 ，返回了13个根域名服务器的主机名。（目前全球一共13个根域名服务器)</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-9.P2.el7 &lt;&lt;&gt;&gt; baidu.com +trace<br>;; global options: +cmd<br>.5INNSg.root-servers.net.<br>.5INNSa.root-servers.net.<br>.5INNSh.root-servers.net.<br>.5INNSf.root-servers.net.<br>.5INNSk.root-servers.net.<br>.5INNSj.root-servers.net.<br>.5INNSe.root-servers.net.<br>.5INNSi.root-servers.net.<br>.5INNSd.root-servers.net.<br>.5INNSm.root-servers.net.<br>.5INNSc.root-servers.net.<br>.5INNSb.root-servers.net.<br>.5INNSl.root-servers.net.<br>;; Received 239 bytes from 192.168.142.2#53(192.168.142.2) in 4047 ms<br><br></code></pre></td></tr></table></figure><p>2、返回<code>com.</code>顶级域名服务器信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">com.172800INNSe.gtld-servers.net.<br>com.172800INNSc.gtld-servers.net.<br>com.172800INNSi.gtld-servers.net.<br>com.172800INNSf.gtld-servers.net.<br>com.172800INNSk.gtld-servers.net.<br>com.172800INNSj.gtld-servers.net.<br>com.172800INNSm.gtld-servers.net.<br>com.172800INNSl.gtld-servers.net.<br>com.172800INNSg.gtld-servers.net.<br>com.172800INNSb.gtld-servers.net.<br>com.172800INNSd.gtld-servers.net.<br>com.172800INNSh.gtld-servers.net.<br>com.172800INNSa.gtld-servers.net.<br>com.86400INDS30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766<br>com.86400INRRSIGDS 8 1 86400 20210226050000 20210213040000 42351 . sKLysaJvml4IZAj8fgWq+Kx5mNwc/K7vEzqlyRqT1xqQqMLajvy4N+cB 4yEK4P7tRZmus5iJ2n1F8ejG90NonpdxrZMZM5XoiqktGHSUt4cA+9bh 5Howi3VOBE94BEyuPOC7S0PZIO41J8kCASOlQRKwn/JgDJ3fxwM3JJU7 hn8OmZ4cQwI8GuBNf2rrdzr7JaywDTAHGPleTR+aHpxbKN/pIQwQqQN4 cv8OaDY1wxonAuDaFrAUKW4Gl3ekNmFKvmo5a2jybDF+wu14NwRX57Ho hAefWTraAeqQLdm1JJ5IM0B+wokDqpOyZG/9hCBPklqhWL8USLeWr//c uUzkig==<br>;; Received 1169 bytes from 202.12.27.33#53(m.root-servers.net) in 133 ms<br></code></pre></td></tr></table></figure><p>3、返回<code>baidu.com.</code>域服务器信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">baidu.com.172800INNSns2.baidu.com.<br>baidu.com.172800INNSns3.baidu.com.<br>baidu.com.172800INNSns4.baidu.com.<br>baidu.com.172800INNSns1.baidu.com.<br>baidu.com.172800INNSns7.baidu.com.<br>CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN NSEC3 1 1 0 - CK0Q1GIN43N1ARRC9OSM6QPQR81H5M9A NS SOA RRSIG DNSKEY NSEC3PARAM<br>CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN RRSIG NSEC3 8 2 86400 20210217054119 20210210043119 58540 com. FD+n+fO9jI2LoVi9ULqvx6lIp8ZP5yC/0HzfnJqiqgTTubTJiVzoVT29 xai2LSeepPqzS/+sehbGHpqOgj21uJoOLePqmaVx/f73ZGcP6Ud2tlkQ QIE++OwDlcQK6P/BM96xdHmGEnG/RaMrFiHV919Xog+sFZddMpjVTtYR q9nST68IU2gLDcNTFeeM7P3CaUdaSRl3LIRz8iuWMrYNSg==<br>HPVUSBDNI26UDNIV6R0SV14GC3KGR4JP.com. 86400 IN NSEC3 1 1 0 - HPVVN3Q5E5GOQP2QFE2LEM4SVB9C0SJ6 NS DS RRSIG<br>HPVUSBDNI26UDNIV6R0SV14GC3KGR4JP.com. 86400 IN RRSIG NSEC3 8 2 86400 20210217071943 20210210060943 58540 com. N5kC7xBpBiXE1kFHNz0QrRWRsebQhrT+zL+oO8yaR0tRQfIhHR1QMNCl Nf6jGiV+W518OfSN16Ypw54wiKf5esFFNChS0LKgp522CUzp8mYYiI5D c8elJwUrD1mYqzLXTjTQF8v2IK3bi/NwWzCasM3K5YEnP2ihO9aLRATU 3l7MdCQC9kajJ8CzkLtA+JsnK0jTP3YsrClYZmS5jKmz4Q==<br>;; Received 757 bytes from 192.43.172.30#53(i.gtld-servers.net) in 276 ms<br></code></pre></td></tr></table></figure><p>4、最终查到了ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">baidu.com.600INA39.156.69.79<br>baidu.com.600INA220.181.38.148<br>baidu.com.86400INNSns3.baidu.com.<br>baidu.com.86400INNSns7.baidu.com.<br>baidu.com.86400INNSdns.baidu.com.<br>baidu.com.86400INNSns4.baidu.com.<br>baidu.com.86400INNSns2.baidu.com.<br>;; Received 240 bytes from 180.76.76.92#53(ns7.baidu.com) in 22 ms<br></code></pre></td></tr></table></figure><p>找到ip地址后会将其存入DNS缓存方便下次查询。</p><h5 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h5><p>如果一个网站用户很多，那么一台机器显然无法满足大量的请求。DNS负载均衡可以在DNS服务器中为一个域名配备多个ip地址，从而引导用户访问到不同的机器。CDN就是负载均衡技术的体现，它把和用户最近的服务器ip返回给用户。</p><h4 id="浏览器进行http请求-服务器返回响应"><a href="#浏览器进行http请求-服务器返回响应" class="headerlink" title="浏览器进行http请求 服务器返回响应"></a>浏览器进行http请求 服务器返回响应</h4><p>http是使用tcp作为传输协议的，关于tcp协议可以参考我的<a href="https://eziozhao.com/article/a44e94be.html">另一篇文章</a>。这一段传输过程可以参考《图解HTTP》中的下图。</p><p><img src="https://gitee.com/eziozhao/image/raw/master/Img/20210213165400.png" alt="image-20210213165353534"></p><h4 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h4><p>浏览器首先解析HTML构建DOM树，然后解析CSS构建CSS规则树，将DOM树和规则树合成渲染树。之后遍历渲染树开始布局，计算每个节点的位置大小信息，将渲染树每个节点绘制到屏幕。具体过程可以参考<a href="https://juejin.cn/post/6844903565610188807">这篇文章</a></p><p><img src="https://gitee.com/eziozhao/image/raw/master/Img/20210213193103.png" alt="image-20210213193103625"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></p><p><a href="https://zhuanlan.zhihu.com/p/133906695">https://zhuanlan.zhihu.com/p/133906695</a></p><p><a href="https://juejin.cn/post/6844903565610188807">https://juejin.cn/post/6844903565610188807</a></p>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带你看看Java中String对象不得不说的那些事</title>
    <link href="/article/cd20e058.html"/>
    <url>/article/cd20e058.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>String是Java中十分常用的类，在面试题中也是出镜率很高的常客，本文将我自己学习中遇到的一些问题进行整理，如果有误，欢迎指正。</p><span id="more"></span><h2 id="String对象判等"><a href="#String对象判等" class="headerlink" title="String对象判等"></a>String对象判等</h2><p>千万不要用 <code>==</code> 去判断String对象是否相等，<code>==</code>比较的是地址。JVM只会共享字符串常量，因此，即使是“看起来”值相同的字符串，用<code>==</code>判断也可能不相等。</p><p>举例来说，下面这段代码中，变量x和y都指向了常量池中共享的<code>&quot;a&quot;</code>，地址相同，但是<code>z</code>是Java堆中的新建对象的引用，其地址与<code>x</code>不同，所以返回了<code>false</code>。</p><p>并且每次<code>new</code>一个<code>String</code>对象时，即使字符串内容相同，也会新开辟一片空间存储对象，因此<code>z</code>和<code>zCopy</code>地址也是不用的。</p><p>这部分的细节原理在下一部分中解释。总而言之，如果你只是想判断两个String对象的内容是否一样，请使用<code>x.equals(z)</code>的形式。</p><p><strong>代码一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs java">String x = <span class="hljs-string">&quot;a&quot;</span>;<br>String y = <span class="hljs-string">&quot;a&quot;</span>;<br>String z = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>);<br>String zCopy = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>);<br>System.out.println(x==y);<span class="hljs-comment">//true</span><br>System.out.println(x==z);<span class="hljs-comment">//false</span><br>System.out.println(z==zCopy);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="String与常量池"><a href="#String与常量池" class="headerlink" title="String与常量池"></a>String与常量池</h2><p><strong>我们在给String类型的引用赋值的时候会先看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用。</strong></p><p><strong>注意：常量池中存放的是引用，并不是实例！！！</strong></p><p>下面结合具体代码来理解这段话，看下面这段代码</p><p><strong>代码二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String x = <span class="hljs-string">&quot;a&quot;</span>;<br>String y = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>String z = <span class="hljs-string">&quot;a&quot;</span>;<br></code></pre></td></tr></table></figure><p>用<code>javap -v -c</code>对<code>.class</code>文件进行反编译后，得到如下结果</p><p><img src="https://gitee.com/eziozhao/image/raw/master/Img/20201217221631.png" alt="image-20201217221631030"></p><p>可以看到，常量池中最中只保留了一份<code>&quot;a&quot;</code>的引用。因为在<code>String z = &quot;a&quot;;</code>执行时，字符串常量池中已经有<code>&quot;a&quot;</code>的引用了，不会重复创建。</p><p>同时我们注意到，对应<code>String y = &quot;a&quot; + &quot;b&quot;;</code>这条语句，因为”a”和”b”都是编译器就能确定的常量，所以常量池只保留了最终计算的结果，并没有单独保留<code>&quot;b&quot;</code>。</p><p>我们将代码稍作修改，然后再次反编译。</p><p><strong>代码三</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String witcher = <span class="hljs-string">&quot;Geralt&quot;</span>;<br>String sorceress = <span class="hljs-string">&quot;Yennefer&quot;</span>;<br>String date = witcher + sorceress;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/eziozhao/image/raw/master/Img/20201217224254.png" alt="image-20201217224254711"></p><p>可以看出，最终常量池只存储了<code>&quot;Geralt&quot;</code>和<code>&quot;Yennefer&quot;</code>两个引用，而没有存放拼接的结果。因为<code>witcher</code>和<code>sorceress</code>变量要运行时才能确定。<strong>但是如果将变量<code>witcher</code>和<code>sorceress</code>都声明为<code>final</code>，那编译期就可以确定，因此拼接结果的引用信息也会放入常量池。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于字符串表达式而言</p><p>1、对于编译期能直接确定的值（字面量、声明为final的变量），会直接将表达式的结果放入常量池。</p><p>2、如果编译期不能直接直接确定（非final的变量），那么只将已经声明字符串字面常量放入常量池，表达式的结果不放入常量池。</p><p>关于常量池的更多介绍欢迎查看我的另一篇博客<a href="https://eziozhao.com/article/7df7aca7.html">一张图秒懂JVM内存区域的划分</a></p><p><strong>另一个出镜率很高的问题是如下的这段代码创建了几个对象？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;xyz&quot;</span>);<br></code></pre></td></tr></table></figure><p>关于这个问题网上众说纷纭，这里放上一种比较靠谱的说法。参考自R神的博客<a href="https://www.iteye.com/blog/rednaxelafx-774673">请别再拿“String s = new String(“xyz”);创建了多少个String实例”来面试了吧</a></p><p>首先，换个问法，这段代码在运行时涉及几个String实例？</p><p>一种合理的解释是：两个，一个是字符串字面量”xyz”所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，另一个是通过new String(String)创建并初始化的、内容与”xyz”相同的实例。</p><h2 id="StringBuilder与StringBuffer"><a href="#StringBuilder与StringBuffer" class="headerlink" title="StringBuilder与StringBuffer"></a>StringBuilder与StringBuffer</h2><p>如果你查看过源码，就会发现String对象是被<code>final</code>修饰的，这意味着它是不可变的。因此，当我们拼接字符串时，会产生新的对象。为此，设计者们提供了<code>StringBuilder</code>类来避免产生过多的中间对象。当我们用<code>+</code>拼接字符串时，编译器会自动帮我们使用StringBuilder进行优化。</p><p>这次使用jad对<strong>代码二</strong>进行反编译（直接用<code>javap -v</code>也可以，但是使用jad产生的结果更容易看懂)</p><p>得到如下结果 可以看到编译器自动为我们使用了<code>StringBuilder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String witcher = <span class="hljs-string">&quot;Geralt&quot;</span>;<br>String sorceress = <span class="hljs-string">&quot;Yennefer&quot;</span>;<br>String date = (<span class="hljs-keyword">new</span> StringBuilder()).append(witcher).append(sorceress).toString();<br></code></pre></td></tr></table></figure><p>有人会说，既然编译器已经优化，我们就直接使用<code>+</code>拼接字符串就可以啊，为什么还要用<code>StringBuilder</code>?</p><p>来看这段代码</p><p><strong>代码四</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String witcher = <span class="hljs-string">&quot;Geralt&quot;</span>;<br>String sorceress = <span class="hljs-string">&quot;Yennefer&quot;</span>;<br>String res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>res += sorceress;<br>&#125;<br></code></pre></td></tr></table></figure><p>对其反编译，可得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String witcher = <span class="hljs-string">&quot;Geralt&quot;</span>;<br>String sorceress = <span class="hljs-string">&quot;Yennefer&quot;</span>;<br>String res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>res = (<span class="hljs-keyword">new</span> StringBuilder()).append(res).append(sorceress).toString();<br></code></pre></td></tr></table></figure><p>可以看出，每一轮的for循环都新建了一个<code>StringBuilder</code>，这是完全没有必要的。因此，我们应该在for循环外部先定义一个<code>StringBuilder</code>对象，这样只新建了一个对象就完成了任务，效率大增。</p><p><code>StringBuffer</code>和<code>StringBuilder</code>基本相同，但是它保证了线程安全，如果有多线程需求，可以按需使用。</p><h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h2><p>我们用下面这段代码来分析intern的作用</p><p><strong>代码五</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String witcher1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Geralt&quot;</span>);<br>String witcher2 = <span class="hljs-string">&quot;Geralt&quot;</span>;<br>System.out.println(witcher1 == witcher2);<span class="hljs-comment">//false </span><br>System.out.println(witcher1.intern() == witcher2);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>第三行显然是false，这在本文最开始已经解释过。</p><p>但是<code>witcher1</code>调用<code>intern</code>之后，地址就与<code>witcher2</code>相同了，这是为什么？</p><p>原来，当一个对象调用<code>intern</code>方法时，会查看常量池是否有与当前对象内容相同的字面量，如果有，就直接返回常量池中的引用信息，如果没有，就在常量池中补充当前对象的字面量，然后返回引用。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>以上就是<code>String</code>类型经常引起疑惑的一些知识点。总结不易，如果有帮到你，希望可以点个赞，谢谢~</p>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年还不懂vue生命周期？一文带你理解vue生命周期那些事</title>
    <link href="/article/a439326f.html"/>
    <url>/article/a439326f.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所谓生命周期，就是vue实例从创建到销毁所经历的一系列过程，掌握生命周期能帮我们更好的了解vue的设计思想，也更方便debug。</p><p>vue为我们提供了一系列钩子函数，方便我们在各阶段进行操作，本文也先从这些钩子函数说起。</p><span id="more"></span><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>我们创建一对父子组件，并通过观察子组件的创建过程，来了解生命周期的变化。</p><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>我是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;show=true&quot;</span>&gt;</span>点我创建子组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span> <span class="hljs-attr">proptest</span>=<span class="hljs-string">&quot;属性值&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/child&quot;</span>;</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                <span class="hljs-attr">show</span>: <span class="hljs-literal">false</span></span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">            child</span><br><span class="javascript">        &#125;,</span><br><span class="javascript"></span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#app</span>&#123;</span><br><span class="css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: aquamarine;</span><br><span class="css">    &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: #6495ed&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>我是子组件<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;year&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeTime&quot;</span>&gt;</span>时光机<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;destroy&quot;</span>&gt;</span>点我销毁子组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;child&quot;</span>,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                <span class="hljs-attr">year</span>: <span class="hljs-string">&#x27;现在是2020年&#x27;</span></span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;proptest&#x27;</span>],</span><br><span class="javascript">        <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">changeTime</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.year === <span class="hljs-string">&#x27;大人，时代变了&#x27;</span> ? <span class="hljs-built_in">this</span>.year = <span class="hljs-string">&#x27;现在是2020年&#x27;</span> : <span class="hljs-built_in">this</span>.year = <span class="hljs-string">&#x27;大人，时代变了&#x27;</span></span><br><span class="javascript">            &#125;,</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">methodsAvailable</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript"></span><br><span class="javascript">            &#125;,</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">destroy</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.$destroy()</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-attr">computed</span>: &#123;</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">time</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now()</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------start-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前是beforeCreate&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-built_in">this</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;el&#x27;</span>, <span class="hljs-built_in">this</span>.$el)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-built_in">this</span>.$data)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-built_in">this</span>.$props)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;watch&#x27;</span>, <span class="hljs-built_in">this</span>._watchers)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;methods&#x27;</span>, <span class="hljs-built_in">this</span>.methodsAvailable)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;computed&#x27;</span>, <span class="hljs-built_in">this</span>.time)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;year&#x27;</span>, <span class="hljs-built_in">this</span>.year)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------end-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------start-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前是created&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;el&#x27;</span>, <span class="hljs-built_in">this</span>.$el)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-built_in">this</span>.$data)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-built_in">this</span>.$props)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;watch&#x27;</span>, <span class="hljs-built_in">this</span>._watchers)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;methods&#x27;</span>, <span class="hljs-built_in">this</span>.methodsAvailable)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;computed&#x27;</span>, <span class="hljs-built_in">this</span>.time)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;year&#x27;</span>, <span class="hljs-built_in">this</span>.year)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------end-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">beforeMount</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------start-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前是beforeMount&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;el&#x27;</span>, <span class="hljs-built_in">this</span>.$el)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-built_in">this</span>.$data)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;year&#x27;</span>, <span class="hljs-built_in">this</span>.year)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------end-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------start-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前是mounted&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;el&#x27;</span>, <span class="hljs-built_in">this</span>.$el)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-built_in">this</span>.$data)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;year&#x27;</span>, <span class="hljs-built_in">this</span>.year)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------end-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="javascript"></span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">beforeUpdate</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------start-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前是beforeUpdate&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;el&#x27;</span>, <span class="hljs-built_in">this</span>.$el.innerHTML)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>.$data))</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;year&#x27;</span>, <span class="hljs-built_in">this</span>.year)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------end-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">updated</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------start-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前是updated&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;el&#x27;</span>, <span class="hljs-built_in">this</span>.$el.innerHTML)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>.$data))</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;year&#x27;</span>, <span class="hljs-built_in">this</span>.year)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------end-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------start-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前是beforeDestroy&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;el&#x27;</span>, <span class="hljs-built_in">this</span>.$el)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-built_in">this</span>.$data)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;year&#x27;</span>, <span class="hljs-built_in">this</span>.year)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------end-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">destroyed</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------start-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前是destroyed&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;el&#x27;</span>, <span class="hljs-built_in">this</span>.$el)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-built_in">this</span>.$data)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;year&#x27;</span>, <span class="hljs-built_in">this</span>.year)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;watch&#x27;</span>, <span class="hljs-built_in">this</span>._watchers)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;methods&#x27;</span>, <span class="hljs-built_in">this</span>.methodsAvailable)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;computed&#x27;</span>, <span class="hljs-built_in">this</span>.time)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------end-------------&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>代码运行后浏览器显示如下</p><p><img src="https://s1.ax1x.com/2020/09/13/wBFJnU.png" alt="wBFJnU.png"></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p> 点击创建子组件按钮，观察控制台打印的信息</p><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><p><img src="https://s1.ax1x.com/2020/09/13/w0XygH.png" alt="w0XygH.png"></p><p>这一阶段，this绑定到了当前实例，但是组件还没有绑定属性，el,data,prop等都处于undefined状态</p><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><p><img src="https://s1.ax1x.com/2020/09/13/w0j9xJ.png" alt="w0j9xJ.png"></p><p>此时data,prop都已绑定，watch开始侦听，computed计算属性生效，methods中的方法已经可以调用。然而，挂载阶段还没开始，$el目前尚不可用</p><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><p><img src="https://s1.ax1x.com/2020/09/13/w0v9Ff.png" alt="w0v9Ff.png"></p><p>准备开始挂载，相关的 render 函数首次被调用，此时$el仍是不可用。至于什么是render函数，可以参考官方这个例子 <a href="https://cn.vuejs.org/v2/guide/render-function.html">https://cn.vuejs.org/v2/guide/render-function.html</a></p><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><p><img src="https://s1.ax1x.com/2020/09/13/w0xFN6.png" alt="w0xFN6.png"></p><p>挂载完成，此时$el已经可用。页面显示如下</p><p><img src="https://s1.ax1x.com/2020/09/13/wBFA6f.png" alt="wBFA6f.png"></p><p>以上几个钩子函数中，created和mounted估计是平时用的最多的，created中可以进行加入数据的初始化逻辑，但是此时还不能操作dom节点。mounted中已经可以操作dom节点，而且eventbus监听一般也放在mounted中。</p><p>注意：如果child组件中还有子组件，那么在child中如果想操作子组件的dom,需要将代码写在nextTick中</p><p>那么当data中的数据更新时，又会发生什么呢？我们点击<code>时光机</code>按钮</p><h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><p><img src="https://s1.ax1x.com/2020/09/13/wBp9Bj.png" alt="wBp9Bj.png"></p><p>可以看到此时data中的值已经改变，但是$el仍未改变。</p><h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><p><img src="https://s1.ax1x.com/2020/09/13/wBpECV.png" alt="wBpECV.png"></p><p>此时$el的也已经更新。</p><p>从官方文档中也可以看出beforeUpdate发生在虚拟DOM重新渲染和打补丁之前，所以个人理解beforeUpdate也许叫beforeDOMUpdate更形象。</p><p><img src="https://s1.ax1x.com/2020/09/13/wBplU1.png" alt="wBplU1.png"></p><p>最后，我们点击<code>销毁</code>按钮</p><h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><p><img src="https://s1.ax1x.com/2020/09/13/wBiIw4.png" alt="wBiIw4.png"></p><p>此时实例依然完全可用，各属性都可调用</p><h2 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h2><p><img src="https://s1.ax1x.com/2020/09/13/wBE7DK.png" alt="wBE7DK.png"></p><p>此时实例已经销毁。清理了与其它实例的连接，解绑它的全部指令及事件监听器。</p><p>但是vm.$destroyed()并不会清除浏览器上的dom。所以更推荐在父组件中直接通过 v-if 来控制子组件的销毁。</p><p>此时虽然有打印值，但是可以看到watch实际上已经是非激活状态，此时再点击界面上的<code>时光机</code>按钮,页面也不再变化。</p><p>自此，vue生命周期过程已经全部介绍完了，如果发现文中有错误，欢迎交流。</p>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手把手教你在vue项目中使用tinymce富文本组件</title>
    <link href="/article/c1e8b599.html"/>
    <url>/article/c1e8b599.html</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">npm install tinymce<br>npm install @tinymce/tinymce-vue<br></code></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>不想看的后面的直接复制走</p><p>1、封装好的richtext组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;template&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">editor</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;tinymceId&quot;</span> <span class="hljs-attr">:init</span>=<span class="hljs-string">&quot;init&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">editor</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> tinymce <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;tinymce/tinymce&#x27;</span></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> Editor <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@tinymce/tinymce-vue&#x27;</span></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;tinymce/themes/silver&#x27;</span></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;tinymce/icons/default/icons.js&#x27;</span></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;tinymce/plugins/image&#x27;</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;RichText&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">id</span>: &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;vue-tinymce-&#x27;</span> + +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() + ((<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">1000</span>).toFixed(<span class="hljs-number">0</span>) + <span class="hljs-string">&#x27;&#x27;</span>)</span></span><br><span class="javascript"><span class="xml">      &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;,</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">value</span>: &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="javascript"><span class="xml">    &#125;,</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">watch</span>: &#123;</span></span><br><span class="javascript"><span class="xml">    value (val) &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.hasChange &amp;&amp; <span class="hljs-built_in">this</span>.hasInit) &#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-built_in">window</span>.tinymce.get(<span class="hljs-built_in">this</span>.tinymceId).setContent(val || <span class="hljs-string">&#x27;&#x27;</span>))</span></span><br><span class="javascript"><span class="xml">      &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  data () &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">const</span> _this = <span class="hljs-built_in">this</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">tinymceId</span>: <span class="hljs-built_in">this</span>.id,</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">hasInit</span>: <span class="hljs-literal">false</span>,</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">hasChange</span>: <span class="hljs-literal">false</span>,</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">init</span>: &#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">language_url</span>: <span class="hljs-string">&#x27;/static/tinymce/zh_CN.js&#x27;</span>, <span class="hljs-comment">// 语言包的路径</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">language</span>: <span class="hljs-string">&#x27;zh_CN&#x27;</span>, <span class="hljs-comment">// 语言</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">skin_url</span>: <span class="hljs-string">&#x27;/static/tinymce/skins/ui/oxide&#x27;</span>, <span class="hljs-comment">// skin路径</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">height</span>: <span class="hljs-number">300</span>, <span class="hljs-comment">// 编辑器高度</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">toolbar</span>: <span class="hljs-string">&#x27; undo redo |  bold italic underline strikethrough image&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">branding</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 去水印</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">elementpath</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 禁用编辑器底部的状态栏</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">statusbar</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏编辑器底部的状态栏</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">paste_data_images</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 允许粘贴图像</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">menubar</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 隐藏最上方menu</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">plugins</span>: <span class="hljs-string">&#x27;image&#x27;</span>, <span class="hljs-comment">// 图片插件</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">images_upload_handler</span>: <span class="hljs-function">(<span class="hljs-params">blobInfo, success, failure</span>) =&gt;</span> &#123;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-comment">// 这里可以请求接口</span></span></span><br><span class="javascript"><span class="xml">          success(<span class="hljs-string">&#x27;data:image/jpeg;base64,&#x27;</span> + blobInfo.base64())</span></span><br><span class="javascript"><span class="xml">        &#125;, <span class="hljs-comment">// 上传本地图片</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">init_instance_callback</span>: <span class="hljs-function"><span class="hljs-params">editor</span> =&gt;</span> &#123;</span></span><br><span class="javascript"><span class="xml">          <span class="hljs-keyword">if</span> (_this.value) &#123;</span></span><br><span class="javascript"><span class="xml">            editor.setContent(_this.value)</span></span><br><span class="javascript"><span class="xml">          &#125;</span></span><br><span class="javascript"><span class="xml">          _this.hasInit = <span class="hljs-literal">true</span></span></span><br><span class="javascript"><span class="xml">          <span class="hljs-comment">// 监听富文本内容的改变 将变化传回richtext的v-model</span></span></span><br><span class="javascript"><span class="xml">          editor.on(<span class="hljs-string">&#x27;NodeChange Change KeyUp SetContent&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.hasChange = <span class="hljs-literal">true</span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;input&#x27;</span>, editor.getContent())</span></span><br><span class="javascript"><span class="xml">          &#125;)</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">      &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">  &#125;,</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-attr">components</span>: &#123;Editor&#125;,</span></span><br><span class="javascript"><span class="xml">  mounted () &#123;</span></span><br><span class="javascript"><span class="xml">    tinymce.init(&#123;&#125;)</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml">&#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>2、在父组件中调用 </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;template&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">RichText</span>  <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;content&quot;</span> /&gt;</span></span><br>&lt;/template&gt;<br>&lt;script&gt;<br><span class="hljs-keyword">import</span> RichText <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/RichText&#x27;</span> <span class="hljs-comment">//记得改路径</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Father&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123; RichText &#125;,<br><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span>&#123;<br><span class="hljs-attr">isShow</span>:<span class="hljs-literal">false</span>,<br><span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;your content&#x27;</span><br>&#125;<br>&#125;<br>&#125;<br>&lt;script/&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>注意：v-model绑定的值会自动赋给RichText的props属性中的value。并且只在初始化时执行一次，如果你希望每次打开富文本编辑框时，都能获取到最新的content值，就要在关闭富文本组件时进行销毁。</p><p>我这里用了v-if来实现，父组件关闭时，将isShow设为false。这样下次打开父组件时，RichText 子组件会重新加载mounted中的 tinymce.init({}) 方法，从而获取最新的content</p><h2 id="在vue项目新建组件"><a href="#在vue项目新建组件" class="headerlink" title="在vue项目新建组件"></a>在vue项目新建组件</h2><p>我这里命名为RichText，注意要在你的组件中import必要的文件。比如icons.js没有引入会导致所有的图标都显示not found</p><p>关于init中的属性说明：</p><p>1、skin_url是必填属性，没有的话会导致组件不能显示。需要到node_modules中找到tinymce对应的文件夹，将其中的skins文件夹复制出来。我这里复制到了 static/tinymce 中，然后在init中填写对应路径</p><p><img src="https://s1.ax1x.com/2020/09/12/waAnII.png" alt="waAnII.png"></p><p>2、没有toolbar属性，组件会只显示一个文本框，所以该属性必填。</p><p>3、具备以上两个属性已经可以实现基本的富文本操作。其他属性的作用参考注释。</p><p>中文语言包可以到<a href="https://www.tiny.cloud/get-tiny/language-packages/">官网</a>下载</p><h2 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h2><p>官方提供了很多插件可供使用，可在init中添加plugins属性。</p><p>注意：使用了一个插件，就要在组件中import它。具体可使用的插件，可在node_modules的tinymce中的plugins中查看</p><p><img src="https://s1.ax1x.com/2020/09/12/waAKit.png" alt="waAKit.png"></p><h2 id="关于图片上传插件"><a href="#关于图片上传插件" class="headerlink" title="关于图片上传插件"></a>关于图片上传插件</h2><p>官方提供的插件默认是直接插入图片的url，但是很多时候，我们希望能直接从本地选取图片。这时需要在init中加入一个images_upload_handler函数进行处理。本文的例子中没有与后端交互。如果需要将图片上传到后台，只需在images_upload_handler中请求接口，并在success中填上请求成功后返回的图片url即可</p>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>富文本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue项目部署到centos7服务器</title>
    <link href="/article/4f35d1fd.html"/>
    <url>/article/4f35d1fd.html</url>
    
    <content type="html"><![CDATA[<h2 id="项目build生成静态文件"><a href="#项目build生成静态文件" class="headerlink" title="项目build生成静态文件"></a>项目build生成静态文件</h2><p>首先将写好的vue项目打包</p><span id="more"></span><div class="code-wrapper"><pre><code class="hljs">npm run build</code></pre></div><p>打包后可以看到项目中多出一个<em>dist</em>文件夹，其中包含了一个<em>static</em>文件夹和index.html页面</p><h2 id="将dist文件上传到服务器"><a href="#将dist文件上传到服务器" class="headerlink" title="将dist文件上传到服务器"></a>将dist文件上传到服务器</h2><p>使用xshell连接服务器，进入你想要存放的目录，本文以/usr/share为例</p><div class="code-wrapper"><pre><code class="hljs">cd /usr/share</code></pre></div><p>在当前目录下输入rz命令，选择压缩后的dist文件，上传</p><p>如果提示command not found，则需要安装rz命令。先切换到root用户，输入以下命令</p><div class="code-wrapper"><pre><code class="hljs">yum -y install lrzsz</code></pre></div><p>安装后就可以正常使用了</p><h2 id="服务器安装配置nginx"><a href="#服务器安装配置nginx" class="headerlink" title="服务器安装配置nginx"></a>服务器安装配置nginx</h2><blockquote><p>Nginx是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。——维基百科</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>因为yum中没有nginx 所以通过以下命令将nginx加入</p><div class="code-wrapper"><pre><code class="hljs"> rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></pre></div><p>使用yum安装</p><div class="code-wrapper"><pre><code class="hljs">yum install nginx</code></pre></div><p>查看版本，验证是否安装成功</p><div class="code-wrapper"><pre><code class="hljs">nginx -v</code></pre></div><p>启动nginx</p><div class="code-wrapper"><pre><code class="hljs">service nginx start</code></pre></div><p>现在，在浏览器中输入服务器的公网ip，就可以看到nginx页面了</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在服务器中打开nginx配置文件，本文路径在*/etc/*下</p><div class="code-wrapper"><pre><code class="hljs">vim /etc/nginx/nginx.conf</code></pre></div><p>打开的配置文件修改对应项</p><div class="code-wrapper"><pre><code class="hljs"> server &#123;    listen       80;    listen       [::]:80;    server_name  你的服务器绑定的域名;    root         你的dist文件存放路径;    location / &#123;        root     你的dist文件存放路径;        index  index.html index.htm;    &#125;&#125;</code></pre></div><p>重启nginx，以后每次修改配置文件都要重启才能生效</p><div class="code-wrapper"><pre><code class="hljs">service nginx restart </code></pre></div><p>现在访问你的服务器ip或域名，就能看到你的项目，恭喜！</p>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用zerotier配置moon结点优化使用体验</title>
    <link href="/article/c783d70.html"/>
    <url>/article/c783d70.html</url>
    
    <content type="html"><![CDATA[<h1 id="zerotier介绍"><a href="#zerotier介绍" class="headerlink" title="zerotier介绍"></a>zerotier介绍</h1><p>这是一款能够帮助你轻松实现虚拟局域网的软件。通过它，你可以将100台设备(免费版账号)加入自己创建的虚拟局域网。且该软件支持支持 Windows、macOS、Linux 三大桌面平台，iOS、Android 两大移动平台。<a href="https://www.zerotier.com/">官网地址</a></p><span id="more"></span><h1 id="注册与使用"><a href="#注册与使用" class="headerlink" title="注册与使用"></a>注册与使用</h1><p>该过程十分简单，按照以下四步即可，具体过程网上资料很多，不再赘述。<br></p><ol><li><a href="https://www.zerotier.com/download/">下载zerotier</a></li><li><a href="https://my.zerotier.com/login">注册</a></li><li>创建自己的Network</li><li>将需要的设备加入虚拟局域网  </li></ol><h1 id="配置中转moon"><a href="#配置中转moon" class="headerlink" title="配置中转moon"></a>配置中转moon</h1><p>国内用户实际使用zerotier时会发现延迟很高。比如在自己搭建的虚拟局域网中使用windows远程桌面，经常卡屏。怎么办呢？别担心，zerotier官方已经帮你想好了解决方案。<br>首先，明确几个名词</p><ul><li>planet 行星节点，zerotier官方提供的根服务器</li><li>moon 卫星节点 用户自己搭建的服务器，可以中转加速</li><li>leaf 相当于用户实际想组成局域网的那些客户端</li></ul><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><p>为了避免不必要的麻烦，以下所有命令都默认在管理员状态下进行</p><div class="code-wrapper"><pre><code class="hljs">sudo -i//该命令可进入管理员状态</code></pre></div><h3 id="1、拥有一台自己的vps"><a href="#1、拥有一台自己的vps" class="headerlink" title="1、拥有一台自己的vps"></a>1、拥有一台自己的vps</h3><p>巧妇难为无米之炊，没有自己的服务器何谈加速一说。moon节点服务器不需要多高的配置，关于如何购买请自行搜索。很多平台现在也支持支付宝等国内软件进行支付。如果你只有短期需求，也可以使用谷歌或亚马逊提供的一年免费云服务，有支持外币的信用卡就可以申请。</p><h3 id="2、在moon服务器中安装zerotier"><a href="#2、在moon服务器中安装zerotier" class="headerlink" title="2、在moon服务器中安装zerotier"></a>2、在moon服务器中安装zerotier</h3><p>复制以下命令  </p><div class="code-wrapper"><pre><code class="hljs">curl -s https://install.zerotier.com/ | sudo bash</code></pre></div><h3 id="3、将moon节点加入网络"><a href="#3、将moon节点加入网络" class="headerlink" title="3、将moon节点加入网络"></a>3、将moon节点加入网络</h3><p>归根结底，moon节点只是你个人的一个加速器，zerotier官方提供的NetWork环境还是必不可少的。moon节点和所有的客户机都需要加入你在zerotier官网创建的network。<br>在moon服务中输入以下命令，其中network id是你在zerotier官网创建的network的id  </p><div class="code-wrapper"><pre><code class="hljs">zerotier-cli join &lt;network id&gt;</code></pre></div><h3 id="4、生成moon-json配置文件"><a href="#4、生成moon-json配置文件" class="headerlink" title="4、生成moon.json配置文件"></a>4、生成moon.json配置文件</h3><div class="code-wrapper"><pre><code class="hljs">cd /var/lib/zerotier-one //进入目录 之后的命令基本都在该目录执行zerotier-idtool initmoon identity.public &gt; moon.json //生成文件</code></pre></div><h3 id="5、修改配置文件"><a href="#5、修改配置文件" class="headerlink" title="5、修改配置文件"></a>5、修改配置文件</h3><p>使用以下命令进入配置文件，按<strong>i</strong>进入编辑状态。</p><div class="code-wrapper"><pre><code class="hljs">[root@moon zerotier-one]# vi moon.json</code></pre></div><p>修改<strong>stableEndpoints</strong>的值，同时记录一下<strong>id</strong>的值，是一个10位字符串，后面有用。</p><div class="code-wrapper"><pre><code class="hljs">&quot;stableEndpoints&quot;: [ &quot;你的vps的ip/9993&quot; ] //9993是zerotier指定的默认端口</code></pre></div><p>修改完成后，按esc退出编辑状态，然后输入**:wq**保存并退出。</p><h3 id="6、生成moon文件"><a href="#6、生成moon文件" class="headerlink" title="6、生成moon文件"></a>6、生成moon文件</h3><p>首先在/var/lib/zerotier-one目录新建<strong>moons.d</strong>文件夹  </p><div class="code-wrapper"><pre><code class="hljs">mkdir moons.d</code></pre></div><p>生成文件  </p><div class="code-wrapper"><pre><code class="hljs">zerotier-idtool genmoon moon.json</code></pre></div><p>并将生成的 moon 文件放到该文件夹中，其中xxx是之前提到的配置文件中的id</p><div class="code-wrapper"><pre><code class="hljs">mv 000000xxxxxxxxxx.moon moons.d/</code></pre></div><h3 id="7、重启vps的zerotier"><a href="#7、重启vps的zerotier" class="headerlink" title="7、重启vps的zerotier"></a>7、重启vps的zerotier</h3><div class="code-wrapper"><pre><code class="hljs">killall -9 zerotier-one</code></pre></div><p>如果提示<strong>killall: command not found</strong>，则需要先安装<br>debian、ubuntu系统下：</p><div class="code-wrapper"><pre><code class="hljs">apt-get install psmisc</code></pre></div><p>centos 下：</p><div class="code-wrapper"><pre><code class="hljs">yum install psmisc</code></pre></div><p>至此，vps上的操作完成。</p><h3 id="8、将客户机连接到你的moon"><a href="#8、将客户机连接到你的moon" class="headerlink" title="8、将客户机连接到你的moon"></a>8、将客户机连接到你的moon</h3><p>zerotier在不同系统的安装目录如下</p><div class="code-wrapper"><pre><code class="hljs">Windows: C:\ProgramData\ZeroTier\OneMacintosh: /Library/Application Support/ZeroTier/One (在 Terminal 中应为 /Library/Application\ Support/ZeroTier/One)Linux: /var/lib/zerotier-one</code></pre></div><p>以<strong>管理员</strong>身份打开命令行，进到安装目录下。输入以下命令<br>注意：如果没有管理员权限，可能会报错</p><div class="code-wrapper"><pre><code class="hljs">zerotier-cli orbit id id //这里的id是之前让你记录的moon.json中的10位字符串</code></pre></div><p>一般到这里就已经连接成功了。如果你还是有报错，可以尝试直接将000000xxxxxxxxxx.moon文件手动拷贝到客户机的<strong>zerotier-one/moons.d</strong>文件夹中。关于如何将vps中的文件下载到本地，可直接使用xshell自带的文件传输功能。<br>重启客户机的zerotier，以<strong>管理员</strong>权限进入命令行的zerotier安装目录，输入以下命令</p><div class="code-wrapper"><pre><code class="hljs">zerotier-cli listpeers</code></pre></div><p>如果出现了带<strong>MOON</strong>字样的节点，代表连接成功。</p><div class="code-wrapper"><pre><code class="hljs">200 listpeers id 你的vps公网ip/9993;2160;2058 196 1.4.6 MOON</code></pre></div><p>现在，你可以重复步骤8，将所有需要的客户机连接到你的私人moon。<br>Congratulations!</p>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
